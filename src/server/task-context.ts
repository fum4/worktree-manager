import { existsSync, readFileSync, writeFileSync, appendFileSync } from 'fs';
import path from 'path';

import { CONFIG_DIR_NAME } from '../constants';
import type { NotesManager, IssueSource } from './notes-manager';

export interface TaskContextData {
  source: IssueSource;
  issueId: string;
  identifier: string;
  title: string;
  description: string;
  status: string;
  url: string;
  comments?: Array<{ author: string; body: string; created?: string }>;
}

export interface PendingTaskContext {
  data: TaskContextData;
  aiContext?: string | null;
}

export function generateTaskMd(data: TaskContextData, aiContext?: string | null): string {
  const lines: string[] = [];

  lines.push(`# ${data.identifier} — ${data.title}`);
  lines.push('');
  lines.push(`**Source:** ${data.source}`);
  lines.push(`**Status:** ${data.status}`);
  lines.push(`**URL:** ${data.url}`);

  if (data.description) {
    lines.push('');
    lines.push('## Description');
    lines.push('');
    lines.push(data.description);
  }

  if (data.comments && data.comments.length > 0) {
    lines.push('');
    lines.push('## Comments');
    lines.push('');
    for (const comment of data.comments) {
      const dateStr = comment.created ? ` (${comment.created.split('T')[0]})` : '';
      lines.push(`**${comment.author}${dateStr}:** ${comment.body}`);
      lines.push('');
    }
  }

  if (aiContext) {
    lines.push('');
    lines.push('## AI Context');
    lines.push('');
    lines.push(aiContext);
  }

  lines.push('');
  lines.push('---');
  lines.push('*Auto-generated by wok3. Updated when AI Context notes change.*');
  lines.push('');

  return lines.join('\n');
}

function getWorktreeGitExcludePath(worktreePath: string): string | null {
  const dotGitPath = path.join(worktreePath, '.git');
  if (!existsSync(dotGitPath)) return null;

  try {
    const content = readFileSync(dotGitPath, 'utf-8').trim();
    // Worktrees have a .git file (not directory) with: gitdir: /path/to/.git/worktrees/<name>
    if (content.startsWith('gitdir:')) {
      const gitDir = content.replace('gitdir:', '').trim();
      return path.join(gitDir, 'info', 'exclude');
    }
  } catch {
    // Not a worktree .git file
  }

  // Regular .git directory
  return path.join(dotGitPath, 'info', 'exclude');
}

function ensureGitExclude(worktreePath: string): void {
  const excludePath = getWorktreeGitExcludePath(worktreePath);
  if (!excludePath) return;

  try {
    let content = '';
    if (existsSync(excludePath)) {
      content = readFileSync(excludePath, 'utf-8');
    }
    if (!content.includes('TASK.md')) {
      const separator = content.length > 0 && !content.endsWith('\n') ? '\n' : '';
      appendFileSync(excludePath, `${separator}TASK.md\n`);
    }
  } catch {
    // Non-critical — ignore
  }
}

export function writeTaskMd(worktreePath: string, content: string): void {
  writeFileSync(path.join(worktreePath, 'TASK.md'), content);
  ensureGitExclude(worktreePath);
}

export function writeWorktreeTaskMd(
  worktreePath: string,
  data: TaskContextData,
  notesManager: NotesManager,
): void {
  const notes = notesManager.loadNotes(data.source, data.issueId);
  const aiContext = notes.aiContext?.content ?? null;
  const content = generateTaskMd(data, aiContext);
  writeTaskMd(worktreePath, content);
}

function loadIssueData(
  configDir: string,
  source: IssueSource,
  issueId: string,
): TaskContextData | null {
  const issueFile = path.join(configDir, CONFIG_DIR_NAME, 'issues', source, issueId, 'issue.json');

  if (source === 'local') {
    const taskFile = path.join(configDir, CONFIG_DIR_NAME, 'issues', 'local', issueId, 'task.json');
    if (!existsSync(taskFile)) return null;
    try {
      const task = JSON.parse(readFileSync(taskFile, 'utf-8'));
      return {
        source: 'local',
        issueId,
        identifier: task.identifier ?? issueId,
        title: task.title ?? '',
        description: task.description ?? '',
        status: task.status ?? 'unknown',
        url: '',
      };
    } catch {
      return null;
    }
  }

  if (!existsSync(issueFile)) return null;

  try {
    const raw = JSON.parse(readFileSync(issueFile, 'utf-8'));

    if (source === 'jira') {
      return {
        source: 'jira',
        issueId,
        identifier: raw.key ?? issueId,
        title: raw.summary ?? '',
        description: raw.description ?? '',
        status: raw.status ?? 'Unknown',
        url: raw.url ?? '',
        comments: raw.comments?.slice(0, 10),
      };
    }

    if (source === 'linear') {
      return {
        source: 'linear',
        issueId,
        identifier: raw.identifier ?? issueId,
        title: raw.title ?? '',
        description: raw.description ?? '',
        status: raw.status ?? raw.state?.name ?? 'Unknown',
        url: raw.url ?? '',
        comments: raw.comments?.map((c: { author?: string; body?: string; createdAt?: string }) => ({
          author: c.author ?? 'Unknown',
          body: c.body ?? '',
          created: c.createdAt,
        })),
      };
    }
  } catch {
    // Corrupt file
  }

  return null;
}

export function regenerateTaskMd(
  source: IssueSource,
  issueId: string,
  worktreeId: string,
  notesManager: NotesManager,
  configDir: string,
  worktreesPath: string,
): void {
  const worktreePath = path.join(worktreesPath, worktreeId);
  if (!existsSync(worktreePath)) return;

  const data = loadIssueData(configDir, source, issueId);
  if (!data) return;

  const notes = notesManager.loadNotes(source, issueId);
  const aiContext = notes.aiContext?.content ?? null;
  const content = generateTaskMd(data, aiContext);
  writeTaskMd(worktreePath, content);
}
